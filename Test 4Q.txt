שאלה 1: מהו תפקיד המתודה init במחלקת פייתון

א. ליצור מופע חדש של המחלקה ולבצע בו אתחול של משתנים


שאלה 2: מה ההבדל המרכזי בין @staticmethod ל־@classmethod בפייתון

ב. @classmethod מקבל את המחלקה כפרמטר ראשון (cls), ו־@staticmethod לא מקבל אובייקט בכלל.

שאלה 3: מהי מטרת השיטה str במחלקת פייתון.

ב. להחזיר ייצוג טקסטואלי של האובייקט כשמדפיסים אותו

הסבר -
המתודה __str__ משמשת להחזיר מחרוזת המייצגת את האובייקט כאשר המופע מודפס.


שאלה 4: מה קורה כאשר מפעילים את האופרטור == על שני מופעים מאותה מחלקה בלי להגדיר את eq

ג. ההשוואה תתבצע לפי כתובת הזיכרון של המופעים


שאלה 5: מה נדרש כדי להפוך מחלקה לאיטרטור בפייתון

ב. לממש את המתודות iter ו-next

הסבר - 
כדי שאובייקט יהיה איטרטור הוא חייב לממש שתי מתודות:
 __next__ - שמחזירה את הפריט הבא באיטרציה ומעלה StopIteration כשאין יותר פריטים 
וגם
 __iter__  - שבמקרה של איטרטור עצמו, פשוט מחזירה את self.


שאלה 6: מהו hash ואיזה תפקיד הוא ממלא

ב. מחזיר ערך מספרי ייחודי שמייצג את האובייקט עבור שימוש במבני נתונים כמו dict או set

הסבר - 
הפונקציה hash משמשת ליצירת מזהה ייחודי לאובייקטים.


שאלה 7: מה מאפשרת המתודה add כאשר היא מוגדרת במחלקה

ב. שימוש באופרטור + בין מופע של המחלקה לכל אובייקט שתואם את הלוגיקה שבמתודה

הסבר - 
המתודה __add__ מאפשרת שימוש באופרטור + בין מופעים של המחלקה לכל אובייקט אחר, אם הוא מוגדר נכון.


שאלה 8: מה יקרה אם נממש eq אך לא נממש hash וננסה להשתמש במופע של המחלקה כ־key במילון (dict)

ג. תתקבל שגיאה מסוג TypeError


שאלה 9: מה היתרון המרכזי בשימוש במחלקה מופשטת (abstract base class) בפייתון

ג. היא מגדירה ממשק מחייב למחלקות שיורשות ממנה


שאלה 10: מה יקרה אם ננסה ליצור מופע ממחלקה שמוגדרת כ־abstract ויש בה מתודה אחת abstract שלא מומשה

ג. תתקבל שגיאה בזמן יצירת מופע.  בגלל שלא ניתן ליצור מופע של מחלקה מופשטת אם היא מכילה מתודה מופשטת שלא מומשה.


שאלה 11: מהי התוצאה של ניסיון לרשת ממחלקה שמסומנת כ־abstract אך לא לממש את כל המתודות ה־abstract

ב. תתקבל שגיאה בזמן יצירת מופע מהמחלקה היורשת - כי לא ניתן ליצור ממנה מופע.


שאלה 12: מה קורה כאשר שני threads ניגשים לאותו משתנה בזיכרון בלי סנכרון מתאים

ג. התוצאה עלולה להיות לא צפויה בגלל מצב של race condition


שאלה 13: מה ההבדל בין *args ל־**kwargs בפייתון

ג. *args אוסף ארגומנטים לפי מיקום ו־**kwargs אוסף ארגומנטים לפי מפתח

הסבר -
*args - מאפשר לפונקציה לקבל מספר בלתי מוגבל של ארגומנטים שאינם לפי מפתח ולאסוף אותם לתוך tuple.

**kwargs - מאפשר לפונקציה לקבל מספר בלתי מוגבל של ארגומנטים המועברים לפי מפתח, ולאסוף אותם לתוך dictionary.


שאלה 14: למה משמשת המתודה hash בפייתון

ב. כדי לאפשר שימוש באובייקט כמפתח במילון או כחבר בקבוצת set

מתודת __hash__ צריכה להיות ממומשת בשביל לאפשר דברים אלו.


שאלה 15: מהי המשמעות של GIL (Global Interpreter Lock) בפייתון

ג. נועל את הקוד שלך כדי למנוע גישה מריבוי משתמשים.  מנגנון המונע (Lock) הרצת מספר threads בו זמנית בקוד.


שאלה 16: מה היתרון המרכזי של שימוש ב־logging על פני print בפייתון

ג. logging מאפשר רמות דיווח שונות וכתיבה לקובץ או קונסולה

הסבר - logging מספקת יותר אפשרויות ויכולת לתעד את פעילות התוכנית בצורה גמישה.


שאלה 17: מה תהיה תוצאת הריצה של הקוד הבא
try:
    result = 10 / 0
except ValueError:
    print("Value error")
finally:
    print("Done")

ג. יודפס "Done" ואז תיזרק שגיאת ZeroDivisionError כי אין except מתאים

הסבר -
ZeroDivisionError תיזרק, אך finally תמיד יבוצע בסוף.


שאלה 18: הקוד הבא רץ לאט וצורך הרבה זיכרון
def process():
    data = create_big_list()
    doubled = double_values(data)
    return sum(doubled)
מהי הדרך הכי טובה לזהות איזו מהפונקציות create_big_list או double_values אחראית לצריכת זיכרון גבוהה 

ג. להשתמש ב־memory_profiler עם @profile כדי למדוד שימוש בזיכרון - מכיוון שיש לו מספק כלים טובים לניתוח צריכת זיכרון של פונקציות.



שאלה 19: מהו מצב של cycle reference בפייתון

ב. מצב שבו שני אובייקטים מחזיקים הפניה אחד לשני, כך שלא ניתן לפנות את הזיכרון

הסבר -
כי יש הפניה מעגלית {cycle reference} , שני אובייקטים מחזיקים האחד בשני ולא יכולים להימחק בזיכרון.



שאלה 20: מה תהיה תוצאת הריצה של הקוד הבא מבחינת ניהול זיכרון
class A:
    def __init__(self):
        self.b = None

class B:
    def __init__(self):
        self.a = None

a = A()
b = B()
a.b = b
b.a = a

ב. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית - ולא יאפשרו ל-Garbage Collector לפנות את האובייקטים מהזיכרון.



שאלה 21: יש לך שני קבצים: module_a.py ו־module_b.py, שכל אחד מהם מייבא פונקציה מהשני
בעת הרצה אתה מקבל שגיאת ImportError או AttributeError בגלל הפניה מעגלית

מהו פתרון מקובל כדי למנוע הפניה מעגלית ועדיין להשתמש בפונקציה מהמודול השני

ב. לשים את ה־import בתוך הפונקציה שזקוקה לו - ומונעת הפניה מעגלית.


שאלה 22: מהי המשמעות של Reference Count בפייתון

ב. מספר המשתנים שמצביעים על אותו אובייקט בזיכרון.


שאלה 23: למה משמשת Weak Reference בפייתון

ב. היא מחזיקה הפניה לאובייקט בלי למנוע מה־garbage collector למחוק אותו - כאשר הוא כבר לא בשימוש.


שאלה 24: מה היתרון בהגדרת תכונה כ־private עם __name ושימוש ב־getter ו־setter עבורה

ג. מאפשר שליטה על גישה, אימות ולוגיקה לפני קריאה או שינוי של הערך - ניהול טוב יותר של שדות פרטיים.


שאלה 25: למה נשתמש ב־multiprocessing במקום ב־threading בפייתון

ג. כי multiprocessing עוקף את מגבלת ה־GIL ולכן מתאים לעומסים חישוביים - ומאפשר הרצה בו זמנית של תהליכים שונים ולמעבר של GIL.